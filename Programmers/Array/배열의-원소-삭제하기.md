## 1. 문제

* **문제 링크:** [[문제 URL](https://school.programmers.co.kr/learn/courses/30/lessons/181844)]
* **난이도:** [Level 0]
* **유형:** [ArrayList/HashSet, ArrayList]

## 2. 풀이
### ArrayList만을 사용한 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(int[] arr, int[] delete_list) {
        // 1. ArrayList를 생성하고, arr 배열의 원소들을 담는다.
        ArrayList<Integer> list = new ArrayList<>();
        for (int n : arr) {
            list.add(n);
        }
        // 2. delete_list가 같은 값을 가지는 원소들을 list에서 제거.
        for (int n : delete_list) {
            list.remove((Integer)n);
        }
        // 3. list를 int[]로 형변환. 
        int len = list.size();        
        int[] ans = new int[len];
        for (int i = 0; i < len; i++) {
            ans[i] = list.get(i);
        }
        
        return ans;
    }
}
```
---

### HashSet과 ArrayList 사용한 풀이
```java
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

class Solution {
    public int[] solution(int[] arr, int[] delete_list) {
        // 1. delete_list를 Set으로 변환하여 검색 속도를 O(1)로 만듬.
        Set<Integer> set = new HashSet<>();
        for (int deleteNum : delete_list) {
            set.add(deleteNum);
        }
        
        // 2. 결과를 담을 List를 생성.
        List<Integer> list = new ArrayList<>();
        
        // 3. arr를 순회하면서 Set에 포함되지 않은 원소만 List에 추가.
        for (int num : arr) {
            if (!set.contains(num)) {
                list.add(num);
            }
        }
        
        // 4. List를 int[] 배열로 변환하여 반환.
        return list.stream()
                         .mapToInt(Integer::intValue)
                         .toArray();
    }
}

// 정리
// 1) 삭제할 원소들을 HashSet에 모두 넣는다.(O(M)).
// 2) arr 배열을 순회하면서(O(N)), 각 원소가 HashSet에 있는지 확인. (O(1)).
// 3) HashSet에 없는 원소만 list에 추가.
// 시간 복잡도: O(N + M). (Set 생성 O(M), arr 순회 O(N))

```
## 3. 문법
### `list.remove((Integer)n)`에서 `(Integer)` 캐스팅 이유

* **설명**: `ArrayList<Integer>`의 `remove()` 메서드는 두 가지 버전으로 오버로딩(Overloading)되어 있기 때문.
    1.  `E remove(int index)`: `int`를 파라미터로 받음. 해당 인덱스(위치)의 원소를 삭제함.
    2.  `boolean remove(Object o)`: `Object`를 파라미터로 받음. 해당 값(value)과 일치하는 첫 번째 원소를 삭제함.

* **문제 상황**:
    * `list`는 `ArrayList<Integer>` ( `Integer` 객체를 저장).
    * `delete_list`의 원소 `n`은 `int` (기본형).

* **`list.remove(n)` (캐스팅 없이) 호출 시**:
    * Java는 `n`이 `int` 타입이므로, `remove(int index)` 메서드를 선택함.
    * 즉, `n`이라는 값을 지우는 게 아니라, `n`번 인덱스에 있는 원소를 지우려고 시도함.
    * **(예시)** `arr = [1, 10, 100]`, `delete_list = [10]`일 때:
        * `list.remove(10)`이 호출됨.
        * Java는 `list`의 10번 인덱스를 지우려 함.
        * `list`의 크기는 3이므로 `IndexOutOfBoundsException` (배열 범위 초과 예외) 발생.

* **`list.remove((Integer)n)` (캐스팅 사용) 호출 시**:
    * `(Integer)n`은 `int` 타입 `n`을 `Integer` (객체) 타입으로 박싱(Boxing)함.
    * Java는 파라미터가 `Integer` (Object) 타입이므로, `remove(Object o)` 메서드를 선택함.
    * `list`에서 `n`과 동일한 값을 가진 첫 번째 `Integer` 객체를 찾아 삭제함. (이것이 의도한 동작)

---

### `ArrayList.remove()` 메서드

#### 1. `E remove(int index)`
* **설명**: 특정 인덱스(위치)의 원소를 삭제함.
* **파라미터**:
    * `int index`: 삭제할 원소의 위치 (0부터 시작).
* **반환값**: `E` (제네릭 타입, e.g., `Integer`)
    * 삭제된 원소를 반환함.

#### 2. `boolean remove(Object o)`
* **설명**: 리스트에서 특정 값(객체)과 일치하는 첫 번째 원소를 찾아 삭제함.
* **파라미터**:
    * `Object o`: 삭제할 값(객체).
* **반환값**: `boolean`
    * `true`: 해당 객체가 리스트에 존재하여 삭제에 성공했을 때.
    * `false`: 해당 객체가 리스트에 존재하지 않아 삭제할 것이 없을 때.

---

### `Set.contains()`

* **설명**: `Set` 컬렉션(e.g., `HashSet`)이 **특정 원소(element)를 포함하고 있는지** 여부를 확인.
* **문법**: `boolean contains(Object o)`
* **파라미터**:
    * `Object o`: 찾으려는 원소(값).
* **반환값**: `boolean`
    * `true`: `Set`이 해당 원소를 포함하고 있는 경우.
    * `false`: `Set`이 해당 원소를 포함하고 있지 않은 경우.
* **특징 (vs. List.contains)**:
    * `Set` (특히 `HashSet`)의 `contains()`는 내부적으로 해시(Hash) 구조를 사용하므로, 데이터의 양과 관계없이 매우 빠름. (시간 복잡도: 평균 O(1))
    * `List` (e.g., `ArrayList`)의 `contains()`는 0번 인덱스부터 순차적으로 탐색하므로, 데이터가 많을수록 느림. (시간 복잡도: O(N))
* **구조 예시**:
    ```java
    // 1. Set 생성 및 값 추가
    Set<String> set = new HashSet<>();
    set.add("apple");
    set.add("banana");
    
    // 2. "apple"이 Set 안에 있는지 확인
    boolean hasApple = set.contains("apple"); // true
    
    // 3. "orange"가 Set 안에 있는지 확인
    boolean hasOrange = set.contains("orange"); // false
    ```
* **사용처**:
    * 코딩 테스트에서 중복을 허용하지 않는 값을 저장할 때.
    * 특정 값이 이미 등장했는지(방문했는지) O(1)의 빠른 속도로 확인할 때.
    * `delete_list`를 `Set`으로 만들어 `arr`를 순회하며 O(1)로 삭제 여부를 판별할 때 유용함.

---

### 스트림(Stream) 문법

#### (1) `.stream()`

* **설명**: `list` (자료형: `List<Integer>`)를 스트림(Stream)으로 변환함.
* **스트림(Stream)**: 컬렉션(List, Set 등)의 원소들을 하나씩 순회하면서 처리할 수 있도록 해주는 데이터 처리 파이프라인.
* **반환값**: `Stream<Integer>` ( `Integer` 객체들이 흘러다니는 파이프라인)

#### (2) `.mapToInt(Integer::intValue)`

* **설명**: 스트림의 각 원소를 매핑(mapping)(변환)하여 `IntStream`을 반환함.
* **`.mapToInt(...)`**:
    * `Stream<T>` (객체 스트림)을 받아 `IntStream` (기본형 `int` 스트림)으로 변환해주는 중간 연산.

#### (3D) `Integer::intValue` (메서드 레퍼런스)

* **설명**: `::` (더블 콜론) 연산자는 메서드 레퍼런스(Method Reference)를 의미.
* **`Integer::intValue`**:
    * `mapToInt`는 "각 원소를 `int`로 어떻게 바꿀지" 방법을 요구함.
    * `Integer::intValue`는 "스트림을 통과하는 `Integer` 객체 각각에 대해 `.intValue()` 메서드를 호출해서 `int` 기본형으로 바꿔라"는 의미.
    * 이는 람다 표현식 `i -> i.intValue()` 또는 `i -> i` (오토 언박싱)와 동일한 축약 표현임.

#### (4) `.toArray()`

* **설명**: 스트림의 모든 원소들을 모아서 배열로 만듦.
* **문법**: `int[] toArray()` (`IntStream`에서 호출 시)
* **파라미터**: 없음.
* **반환값**: `int[]` (`int` 기본형 배열).
