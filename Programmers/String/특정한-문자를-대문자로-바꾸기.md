

## 1. 문제

* **문제 링크:** [[문제 URL](https://school.programmers.co.kr/learn/courses/30/lessons/181873?language=java)]
* **난이도:** [Level 0]
* **유형:** [String/Character]

## 2. 풀이

```java
class Solution {
    public String solution(String my_string, String alp) {
        String upperStr = alp.toUpperCase();
        return my_string.replaceAll(alp, upperStr);
    }
}
```

## 3. 문법

### `String.toUpperCase()`

* **설명**: 문자열의 **모든 알파벳 문자**를 **대문자**로 변환한 **새로운 `String`**을 반환함. (원본 문자열은 변경되지 않음)
* **문법**: `String toUpperCase()`
* **파라미터**: 없음.
* **반환값**: `String` (모든 문자가 대문자로 변환된 새 문자열).
* **Typical 구조 예시**:
    ```java
    String str = "Hello World";
    String upperStr = str.toUpperCase(); // upperStr은 "HELLO WORLD"
    ```
* **사용처**:
    * 대소문자를 구분하지 않고 문자열을 비교해야 할 때. (e.g., `"apple".toUpperCase().equals("APPLE".toUpperCase())`)
    * 문제에서 출력을 대문자로 요구할 때.

---

### `replace()` vs `replaceAll()`

#### `String.replace()`

* **설명**: 문자열의 **모든** `target` 문자열(또는 문자)을 `replacement` 문자열(또는 문자)로 **있는 그대로(Literal)** 치환한 **새 `String`**을 반환.
* **문법**: `String replace(CharSequence target, CharSequence replacement)`
* **파라미터**:
    * `CharSequence target`: 찾을 대상 문자열 (e.g., `"abc"`).
    * `CharSequence replacement`: 바꿀 새 문자열 (e.g., `"xyz"`).
* **반환값**: `String` (치환된 새 문자열).
* **Typical 구조 예시**:
    ```java
    String str = "hello.world";
    // "."을 "!"로 치환
    String replaced = str.replace(".", "!"); // replaced는 "hello!world"
    ```

#### `String.replaceAll()`

* **설명**: 문자열에서 `target` **정규표현식(Regex)**에 **매칭되는 모든 부분**을 `replacement` 문자열로 치환한 **새 `String`**을 반환.
* **문법**: `String replaceAll(String regex, String replacement)`
* **파라미터**:
    * `String regex`: 찾을 대상 **정규표현식** (e.g., `"[0-9]"`).
    * `String replacement`: 바꿀 새 문자열.
* **반환값**: `String` (치환된 새 문자열).
* **Typical 구조 예시**:
    ```java
    String str = "ab12cd34ef";
    // 정규식: "[0-9]" (숫자 하나)를 "X"로 모두 치환
    String replaced = str.replaceAll("[0-9]", "X"); // replaced는 "abXXcdXXef"
    ```

#### 차이 및 사용처

* **핵심 차이**: `replace()`는 **일반 문자열(Literal)**을, `replaceAll()`은 **정규표현식(Regex)**을 기준으로 찾음.
* **사용처 `replace()`**:
    * 단순히 `"a"`를 `"b"`로 바꾸는 등, 명확한 문자열을 치환할 때.
* **사용처 `replaceAll()`**:
    * "모든 숫자", "모든 공백", "모든 특수문자" 등 **패턴**에 맞는 것들을 치환할 때.
* **주의**: 정규식에서 특별한 의미를 갖는 문자(e.g., `.`, `+`, `*`, `?`, `\`)를 `replaceAll()`로 치환하려면 이스케이프(`\\`)가 필요함.
    * `str.replaceAll("\\.", "!");` (정규식이 아닌 문자 `.` 자체를 의미)

---

### `String.equals()`

* **설명**: 두 `String` 객체의 **내용(문자열 값)이 동일한지** 비교함.
* **`==`와의 차이**:
    * `s1.equals(s2)`: `s1`과 `s2`의 **값(내용)**이 같은지 비교 (e.g., "hello"와 "hello"는 `true`). **문자열 비교는 항상 `equals` 사용.**
    * `s1 == s2`: `s1`과 `s2`가 힙(Heap) 메모리에서 **완전히 동일한 객체(주소)**를 참조하는지 비교. (값이 같아도 `false`가 나올 수 있음)
* **문법**: `boolean equals(Object anObject)`
* **파라미터**:
    * `Object anObject`: 비교할 대상 객체 (주로 `String`).
* **반환값**: `boolean` (값이 같으면 `true`, 다르면 `false`).
* **Typical 구조 예시**:
    ```java
    String s1 = "hello";
    String s2 = "hello";
    String s3 = new String("hello"); // 새 객체 생성

    boolean check1 = s1.equals(s2); // true (내용이 같음)
    boolean check2 = s1.equals(s3); // true (내용이 같음)
    
    boolean check3 = (s1 == s2); // true (Java가 리터럴을 최적화하여 같은 주소 참조)
    boolean check4 = (s1 == s3); // false (s3는 new로 만들었으므로 다른 주소)
    ```

---

### `.split()`

* **설명**: `String`을 특정 **구분자(delimiter)**를 기준으로 잘라서 **`String` 배열 (`String[]`)**로 반환함.
* **문법**: `String[] split(String regex)`
* **파라미터**:
    * `String regex`: 문자열을 자를 기준이 되는 **정규표현식(Regex)**.
* **반환값**: `String[]` (잘린 문자열 조각들이 담긴 배열).

#### `split(String regex)` (일반)

* **Typical 구조 예시**:
    ```java
    String str = "apple,banana,orange";
    
    // ","를 기준으로 자름
    String[] fruits = str.split(",");
    // fruits는 ["apple", "banana", "orange"]

    String str2 = "a b c";
    String[] words = str2.split(" ");
    // words는 ["a", "b", "c"]
    ```
* **주의**: `split()`의 기준은 **정규표현식**임. `.`이나 `|` 등 특수문자로 자를 때는 이스케이프(`\\.`, `\\|`) 필요.

#### `split("")` (빈 문자열 기준)

* **설명**: 빈 문자열(`""`)을 기준으로 자르면, 문자열이 **한 글자씩** 모두 분리되어 `String[]`에 담김.
* **Typical 구조 예시**:
    ```java
    String str = "hello";
    String[] chars = str.split("");
    // chars는 ["h", "e", "l", "l", "o"]
    ```
* **사용처**:
    * 문자열을 한 글자씩 `String`으로 쪼개서 다루고 싶을 때.
    * `toCharArray()`는 `char[]` (문자 배열)을 반환하는 반면, `split("")`은 `String[]` (문자열 배열)을 반환함.

---

### `String[] arr`

* **설명**: `String` (문자열) 타입의 데이터 여러 개를 담을 수 있는 **배열(Array)** 자료구조.
* **특징**:
    * `new String[크기]`로 생성 시 크기가 고정됨.
    * 각 인덱스(`arr[0]`, `arr[1]`, ...)에 `String` 객체를 저장.
    * 초기화하지 않은 인덱스의 기본값은 `null`.
* **Typical 구조 예시**:
    ```java
    // 1. 크기 3의 String 배열 선언 및 생성
    String[] arr1 = new String[3];
    arr1[0] = "Java";
    arr1[1] = "Spring";
    // arr1[2]는 null
    
    // 2. 선언과 동시에 초기화
    String[] arr2 = {"apple", "banana", "orange"};
    
    // 3. String.split()의 결과로 생성됨
    String[] arr3 = "a b c".split(" "); 
    ```

---

### `Character` (래퍼 클래스)

* **설명**: 기본 자료형(primitive) `char`를 객체(Object)로 감싼 **래퍼 클래스(Wrapper Class)**.
* **사용처**:
    * `ArrayList<Character>`처럼 제네릭에서 `char` 대신 사용.
    * `char`와 관련된 유용한 **정적(static) 유틸리티 메서드**를 제공함. (코테에서 주로 사용되는 목적)

* **주요 정적 메서드 (코테 빈출)**:
    * **`boolean Character.isDigit(char ch)`**:
        * 해당 문자가 **숫자**('0'~'9')인지 확인.
        * `Character.isDigit('1')` -> `true`
        * `Character.isDigit('a')` -> `false`
    * **`boolean Character.isLetter(char ch)`**:
        * 해당 문자가 **알파벳**인지 확인.
        * `Character.isLetter('a')` -> `true`
        * `Character.isLetter('9')` -> `false`
    * **`boolean Character.isLetterOrDigit(char ch)`**:
        * 알파벳 또는 숫자인지 확인.
    * **`char Character.toLowerCase(char ch)`**:
        * 해당 문자를 소문자로 변환 (알파벳이 아니면 그대로 반환).
    * **`char Character.toUpperCase(char ch)`**:
        * 해G당 문자를 대문자로 변환.
    * **`int Character.getNumericValue(char ch)`**:
        * 문자 '0'~'9'를 `int` 값 0~9로 변환.
        * `Character.getNumericValue('7')` -> `7` (int)
        * (참고) `(int) '7'`은 아스키코드 값 `55`임. `('7' - '0')`과 동일한 기능.
